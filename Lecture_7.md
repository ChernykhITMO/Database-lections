После того, как появились идеи сетей, БД стали более централизованные.

Кроме клиент-серверной конструкции есть проблема производительности 

Есть два способа: 
*Вертикальная масштабируемость* - x2 (стоимость х10) 
Значительно увеличить производительность за дёшево не получится

Горизонтальая масштабируемость - можем докупить какое-то количество устройств и поручить выполнять им функции
Поможет решить проблему производительности, но появляется проблема передачи данных

Удалённость от контента подвела к появлению распределённых БД

Распределённая БД - набор узлов, которые хранят в разных географических или логических точках некоторые наборы данных и эти данные логически связаны

Можно хранить отдельные таблица на разных серверах, но это не совсем то что нужно
Распределённые БД данных хранят раздельные логические данные

Существует несколько вариантов распределения:
1. Горизонтальное
Раскидать строки таблиц по разным серверам 

Пример: европейские данные мастеркард, американские 

2. Вертикальное 
Таблица, раскидываем столбцы по разным серверам 

Если строчка представляет собой неравномерное по нагрузке данных
Есть к примеру ФИО и бинарные данные
Совершенно логично вынести бинарные данные на логическое другое место, потому что к ним доступ будет реже

3. Гибридность 
Данные разносятся по узлам 
Как узлы между собой синхронизировать? 

Существуют:
1. **Раздельное** (каждый фрагмент данных хранится только на одном узле) (в виде одной копии) 
(единственный плюс - цена)
минус: потеря хоть одного узла - теряем часть данных 
- невысокая надёжность
- низкая доступность

2. **Размещение с полной репликацией**
Процесс репликации - процесс переноса данных от одного узла к другому
- данные хранятся с полной копией на разных узлах
*плюс:*
выход одного из узлов не скажется особо на системе
*минус:*
дорого

3. **Частичная(выборочная ) репликация**
- данные на каких-то узлах дублируются, на каких-то нет 
*плюс:* хранение данных, цена меньше
*минус:* надо контролировать 

Существует несколько подходов к управлению репликацией
1. **Мастер слейв**
Есть центральный сервер - мастер, который управляет репликацией 
При этом есть общее правило: **Мастер** может только писать и читать данные, а **Слейв** только отдавать

Дёшево и сердито, но нужно контролировать Мастера, и медленное обновление данных

2. **Мастер Мастер**
Это сервера, которые имеют право и читать и писать, включая и читать и писать на соседей

Сложный подход, очень дорого контролировать 

3. **P2P** - похож на Мастер Мастер, но при этом каждый узел самостоятельный, он не даёт другим писать, но может отдать данные 


**Распределённые СУБД** - комплекс программ, которые обеспечивают управлением распределённых БД

Для распределённых СУБД должно выполняться строгое требование **прозрачности** - это значит, что любое обращение пользователя к СУБД с целью получить данные, приводят к тому же результату, если бы эти данные были в обычной БД (не распределённой)

Уровни прозрачности:
1. Прозрачность фрагментаций
Пользователь не видит, что система фрагментирована
2. Прозрачность размещения фрагментов
Пользователь не знает ,на каком конкретном узле расположен тот фрагмент, к которому он обращается
3. Прозрачность количества реплик
Пользователь не знает, сколько раз данные продублировались
4. Прозрачность контроля доступа
Пользователю не нужны никакие права доступа к другим узлам, он работает со своим узлом и все остальные узлы обслуживают с тем контролем доступом, которые есть

Распределённый СУБД бывают:
1. Гомогенные - однородные по ПО 
Все узлы работают под одной ОС, под одним СУБД 
Гомогенность подразумевает, что тип СУБД - один (очев, один софт - один тип)

Data Lake - озеро данных
Подразумевает, что данные хранятся на различных типах серверов 

2. Гетерогенные системы - различные типы серверов 
Реляционные, Хэш и тд 


Теорема CAP
**Consistency** - Согласованность (консистентность)
**Availability** - Доступность 
**Partition Tolerance** - Устойчивость к разделению
	**Consistency** - ситуация, когда все пользователи видят данные в один и тот же момент времени, т.е. данные одинаковые для всех пользователей
	**Availability** - гарантированный доступ к данным, т.е. каждый запрос получает гарантированный ответ
	**Partition Tolerance** - при отказе в обслуживании узла, система продолжит работать с той же эффективностью, что и раньше 

Максимум можно достигнуть два требования одновременно

Это во многом основано на том, что существует понятие синхронность и асинхронность репликаций

**Синхронность** - запись происходит на все нужные нам узлы 
Повышает консистентность, но снижает производительность 
Как происходит: Данные попадают на один узел, и они помечаются, как валидные, только после того, как все узлы дали ответ, что они записали эти данные

**Асинхронность** - данные записываются только на один узел, и с течением времени расползаются по всей системе

В этой ситуации запись по производительности увеличивается, но консистентность ниже плинтуса

Процесс разделения данных на логические блоки - Sharding

Распределённые системы:
Microsoft, Oracle
Casandra - No SQL система с высокой горизонтальной масштабируемостью
MongoDB - No SQL документоориентированная БД
Amazon Dynamic DB - облачная штука, которая умеет распределяться

Дейт занимался теорией БД и написал 12 правил распределённых БД

Эти правила определяют требования прозрачности 

1. Локальная автономность 
Локальные данные принадлежат локальному хосту и локально управляются.
Этими данными нельзя управлять извне.
Это значит, что мы можем этот узел изолировать и работать с ним, как с собсвтенным
2. Для высокой прозрачности должна отсутствовать опора на центральный узел 
Такие системы называются одноранговыми, т.е. все узлы равномерные. Не может быть такого, что вышибание одного из узлов приведёт к потери всей системы. Вышибание одного из узлов может привести к потери каких-то данных.
3. Непрерывное функционирование 
Не может возникнуть ситуация, когда распределённое СУБД выключается для профилактических работ. Т.е. оно может работать непрерывно
4. Независимость от физического расположения
Неважно, где расположены узлы
5. Независимость от фрагментации
Неважно, как и на какие фрагменты разбиты данные, пользователь всегда получает к ним доступ 
6. Независимость от репликаций 
Пользователь в каждый момент получения данных, гарантировано уверен, что эти данные актуальные и нигде в системе нет других
7. Обработка распределённых запросов 
Когда одна единица информации хранится в одном месте, нет проблем с дублированием информации
Как только появляется несколько копий данных, возникает проблема, из какого узла быстрее брать данные
Пример: Человек отправляет из Германии в Чехию высокоскоростной почтой билет, и видит, как его билет был в ОАЭ, и только потом в Чехию
8. Проблема распределённых транзакции
Должны поддерживаться распределённые транзакции 
Транзакции - набор команд, которые воспринимаются, как единое целое, здесь всё тоже самое, только распределённые
9. Независимость от оборудования
10. Независимость от ПО
11. Независимость от СУБД
12. Независимость от ОС 

**Двухфазные транзакции** - конструкция, когда на первом этапе узел подтверждает, что он готов обработать транзакцию, а на втором этапе реально её обрабатывает

На практике это означает, что сначала мы должны известить все узлы, что началась транзакция, получить от всех узлов готовность её обработать и только после этого выполнять эту транзакцию целиком


**Преимущества распределённых СУБД**
1. Максимально близки к структуре организации (каждый отдел имеет свою БД)
2. Разделяемость и потенциальная локальная автономность 
Каждый узел может существовать и обрабатывать интересы локальных пользователей и при необходимости выступать в роли узла распределённой системы
3. Повышение доступности данных
Мы можем получить данные от соседей
4. Повышение надёжности 
Т.к. хранятся копии на разных узлах, то не так страшно потерять на одном узле информацию
5. Повышение производительности 
6. Модульность системы
Горизонтальная масштабируемость 

**Недостатки**:
1. Сложность 
Сложности бывают двух видов:
- Сложность, как отображение реального мира 
-  Сложность сделать так, чтобы данные распределялись 
2. Если всё начинает быть сложным, то начинает быть дорогим
3. Проблемы защиты
Проблема в том, что каждый узел автономен, следовательно там автономные права, автономные доступы, следовательно проблема управления безопасностью
4. Проблема целостности данных(данные должны отображать предметную область)
Процесс репликации
5. Отсутствие стандартов, как таковых
Стандартные взаимодействия

Первый стандарт - револьвер
Можешь 10 револьверов взять, разобрать, кинуть в мешок и потом из разных частей опять собрать 10 револьверов

### No SQL системы

Not Only SQL системы

Есть закон Мура - удвоение данных 
Реляционные модели не очень справлялись с однотипным хранением данных
В реляционных БД не любят хранить большие куски данных, к примеру - фотографии

Первый тренд: По закону Мура количество информации начало расти 
Количество информации, которое представляет ценность, оно не значительное
Валяется просто так 
Огромное количество данных, которое можно накопать, они вообще не ценны
на 20 год только 3% данных имели ценность (ценность информации - готовность за неё заплатить)
Информации в бесплатном доступе нет, вся информация, которая есть в общем доступе, за неё платят, т.е. за доступ к серверу, реклама и тд

Второй тренд: Информации нет изолированной, как таковой, т.е. огромное количество информации стало связано либо прямыми ссылками, либо косвенными

В традиционных БД не умеют это хранить и отслеживать

Одну и ту же фотографию можем найти на разных страницах 
Т.е. она связывает две страницы

Третий тренд: Слабоструктурированная информация - её нужно:
1. обрабатывать 
2. хранить 
Для описания одной единицы товаров, появилось в разы больше параметров, что позволяет пользователю сделать лучше выбор 
Мы должны вычленить какие-то параметры из описания

Последний тренд:
Исчезновение идеи мейнфреймов
Мейнфрейм - суперкомпьютер
Идея: Мы поставим суперкомпьютер, и он у нас будет всё хранить, обрабатывать
Выяснилось, что это утопическая идея, это идея вертикальной масштабируемости 

А горизонтальная масштабируемость привела к облачным сервисам
Дали 4 ядра, дали 8

Поэтому появились No SQL системы (отличные от реляционных моделей)

**Агрегатор** - механизм, который позволяет группировать некоторые данные и хранить их по каким-то признакам

Агрегатный подход: 
Оптимизация под какой контректный тип запросы
И плюс и минус, т.е. конкретный запрос, но быстро 
Высокая скорость
Хранение данных в том виде, который оптимизирован для конкретного приложения
Внутренняя поддержка атомарности (на уровне приложения)

Позволило решить кучу проблем:
1. Реляционные БД всегда медленные 
2. Реляционые БД не умеют хранить данные в нужном нам виде (нормализация)
3. ACID (атомарность, консистентность, изоляция, устойчивость) то есть (atomicity, consistency, isolation, durability) - жертвами этой слабой асид штуки стали 
overbooking - когда продают билетов больше, чем мест

Появилась конструкция Base (Base Availible ) - каждый запрос так или иначе завершается 

Конструкция BASE - (Base Availble)
каждый запрос так или иначе завершается

S - Soft State (мягкое состояние) - конструкция, когда БД может меняться, даже если данные не поступали 
E - (согласованность в конечном итоге) - пр. в самолёте полетит человек не больше, сколько есть мест (overbooking)












