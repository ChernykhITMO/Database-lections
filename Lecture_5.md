### Нормализация 
Нормализация - это приведение БД к неким нормальным формам

Задачи, которые решает нормализация:
1. Уменьшение дублирования информации
2. Уменьшение объёмов хранения информации (когда делаем JOIN, то появляется много NULL значений)
3. Исключение аномалий 
Таблица: регион проживания
(Северо-западный, Северо-Западный) - 2 разные единицы информации
Т.е. может появиться ситуация, когда добавим данные, которые чуть-чуть не корректны, т.е. будут **аномальные данные**

Мы можем неправильно изменить данные, будет **аномалия** **изменения**

И так же есть **аномалия удаления**

Пример: таблица Product, таблица ProductCategory, в таблице Product есть ProductIdCategory, который ссылается на таблицу ProductCategory. 
Есть категории 1,2,3,4,5 и категорию 5 удалили
Произойдёт ситуация, что некоторое количество строк в таблице Product будет иметь значение 5, которого больше нет - будет **аномалия**

Реакция SQL сервера:
1. SQL отказывает в операции удаления
2. Автоматически все пятёрки в Product заменить на NULL
3. Заменить все пятёрки на какое-то базовое значение
4. Игнорировать
5. Каскадные действия (удалить пятую категорию, а перед этим удалить все товары пятой категории)
Каскадные удаления могут повлечь за собой удаления нужной информации

Одна из задач нормализации - уйти от этих аномалий

Для того, чтобы делать нормализацию - нужно делать декомпозицию
Декомпозиция - разбиение таблицы на две или более, чтобы их можно было соединить обратно без потерь

##### **Декомпозиция без потерь**

| Фамилия | Работа | Город |
| ------- | :----: | ----- |
| Иванов  |   HR   | МСК   |
| Петров  |   IT   | СПБ   |
| Сидоров |   IT   | МСК   |
->

| Фамилия | Работа |
| ------- |:------:|
| Иванов  |   HR   |
| Петров  |   IT   |

##### **Декомпозиция с потерями**

| Товар | Поставщик | Цена |
| :---: | :-------: | :--: |
| Лампа |     А     | 100  |
| Лампа |     Б     | 150  |
| Стул  |     А     | 200  |

->

| Товар | Поставщик |
|:-----:|:---------:|
| Лампа |     А     |
| Лампа |     Б     |
| Стул  |     А     |

| Поставщик | Цена |
|:---------:| ---- |
|     А     | 100  |
|     Б     | 150  |
|     А     | 200  |
##### 


### 1.**Функциональная зависимость**

- **Функциональная зависимость** — это отношение между двумя атрибутами в таблице, когда значение одного атрибута однозначно определяет значение другого.
- Пример: если мы знаем значение одного атрибута, например, **Номер региона**, то мы можем однозначно узнать **Название региона**.
    - Например: **82** (номер региона) — это либо **Крым**, либо **СПБ**. Но если один номер может означать несколько разных регионов, то зависимость не является функциональной.

### 2. **Частичная функциональная зависимость**

- **Частичная функциональная зависимость** возникает, когда **неключевой атрибут** зависит от **части потенциального ключа**, а не от всего ключа. То есть, в отношении, где у нас составной ключ (ключ из нескольких атрибутов), один из атрибутов зависит не от всего ключа, а только от его части.
    
- Пример:
    
    - Пусть у нас есть составной ключ **(Фамилия, Номер группы)**, который уникально идентифицирует строку в таблице.
    - Если **Номер группы** однозначно определяет **Факультет**, то можно сказать, что **Факультет** зависит от **Номера группы**. То есть, в этом случае факультет можно получить только по **Номеру группы** (например, для группы **М3219** факультет будет **ИТиП**).
    - Однако, поскольку мы используем составной ключ, и факультет зависит только от одной части ключа (Номера группы), такая зависимость называется **частичной функциональной зависимостью**.



### 3. **Полная функциональная зависимость**

**Полная функциональная зависимость** — это ситуация, когда атрибут **зависит от всего первичного ключа**.
### 4. **Транзитивная зависимость**

**Транзитивная зависимость** — это ситуация, когда:

- Атрибут **A** определяет атрибут **B**,
- Атрибут **B** определяет атрибут **C**,
- В этом случае **C** транзитивно зависит от **A** через **B**.

**Пример:**

- Пусть у нас есть таблица, где:
    - **Факультет** (атрибут A) определяет **Образовательную программу** (атрибут B).
    - **Образовательная программа** (атрибут B) определяет **Номер группы** (атрибут C).

Таким образом, **Номер группы** (C) транзитивно зависит от **Факультета** (A) через **Образовательную программу** (B). Это называется транзитивной зависимостью.
## Нормальные формы

**Первая нормальная форма** - гарантие того, что таблица может быть рассмотрена, как отношение

Любое отношение - таблица, не всякая таблица - отношение

Т.е. таблица в первой нормальной форме соответствует:
- все кортежи уникальны
- значение ячейки - **атомарно**

Пример нарушения: 

| Имя  | Предметы           |
| ---- | ------------------ |
| Олег | Математика, Физика |

Выход:

| Имя  | Предмет    |
| ---- | ---------- |
| Олег | Математика |
| Олег | Русский    |

Уровень атомарности определяется во многом бизнес логикой 
В современном мире может быть значение ячейки XML, JSON, там об атомарности уже не говорится

**Вторая нормальная форма** - отсутствие частиных зависимостей, приведение только к полной функциональной зависимость 

**Вторая нормальная форма** - отношение в первой нормальной форме и все атрибуты полно зависят от первичного ключа, т.е. отсутствуют частичные функциональные зависимости

Пример:
Учебное заведение

| Номер курса | Номер студента | Фамилия | Название курса |
|:-----------:|:--------------:|:-------:|:--------------:|
|     100     |       1        | Иванов  |     Лепка      |
|     100     |       2        | Петров  |     Лепка      |
|     101     |       1        | Иванов  |   Рисование    |


Получается ситуация, когда номер курса и номер слушателя составляют первичный ключ, но при этом название курса зависит только от номера курса

Номер курса и номер слушателя надо вытащить в отдельную таблицу 

**Третья нормальная форма** - отношение находится во второй нормальной форме и все не ключевые атрибуты взаимно-независимы, т.е. зависят от первичного ключа

Пример несоблюдения:

| ID работника | Фамилия | Номер отдела | Отдел |
| :----------: | ------- | :----------: | ----- |
|      1       | Иванов  |      5       | HR    |
|      2       | Петров  |      6       | IT    |


Название отдела зависит от номера отдела
Т.е. есть два неключевых атрибута, между которыми есть зависимость


Нам нужно отдел или номер отдела вынести в отдельный столбец

Есть правило: как только дошли до третьей нормальной формы, можно дальше не идти

**Нормальная форма Бойсса-Кодда(БКНФ)** - продолжение третьей нормальной формы

Детерминанты (определители зависимостей) являются потенциальными ключами

Пример:

| ID студента | ФИО | Номер проекта | Роль студента в проекте |
| :---------: | --- | :-----------: | ----------------------- |

Один студент может участвовать в нескольких проектах => Id студента не может быть первичным ключом 
Пара Id студента и роль студента - является первичным ключом

Предположим, что ФИО является уникальным ключом
Тогда ФИО тоже потенциальный ключ

Следовательно, два набора потенциальных ключей:
1. ФИО + номер проекта
2. Id студента + номер проекта

Получается, если мы хотим заменить одного студента на другого, то мы должны заменить его имя на другое и заменить айдишник
Получается ситуация, что нужно менять два столбца
Ситуация, Id студента - определяет фамилию, но сам по себе не является первичным ключом, но является первичным ключом только в паре
Т.е. **Нормальная форма Бойсса-Кодда** говорит нам о том, что детерминант должен быть потенциальным ключом (не может быть ситуация, что какая-то часть потенциальная ключа зависит от другой части потенциального ключа, фамилия зависит от номер студента)

Для того, чтобы избегать таких коллизий, нужно избегать составных потенциальных ключей, иначе получится большая беда

**Четвёртая нормальная форма** - ситуация, когда таблица в БКНФ и отсутствуют многозначные зависимости 

| Преподаватель | Предмет    | Язык       |
| ------------- | ---------- | ---------- |
| Иванов        | Математика | Русский    |
| Иванов        | Математика | Английский |
| Иванов        | Физика     | Русский    |
| Иванов        | Физика     | Английский |

Получается две независимые зависимости
Преподаватель - предмет, и преподаватель - язык

**Многозначная зависимость** - ситуация, когда есть независимые зависимости внутри отношения

->

| Преподаватель | Предмет    |
| ------------- | ---------- |
| Иванов        | Математика |
| Иванов        | Физика     |

| Преподаватель | Предмет    |
| ------------- | ---------- |
| Иванов        | Английский |
| Иванов        | Русский    |

Мало отношения имеет к реальному миру

**Пятая нормальная форма** - соединение зависимостей, отношение находится в четвёртой нормальной форме и не может быть декомпозирована без потери данных

| Проект | Фамилия | Роль        |
| ------ | ------- | ----------- |
| А      | Иванов  | Разработчик |
| А      | Иванов  | Аналитик    |
| B      | Сидоров | Аналитик    |
| B      | Петров  | Разработчик |
| B      | Сидоров | Разработчик |

Делаем декомпозицию

| Проект | Фамилия |
| ------ | ------- |
| А      | Иванов  |
| B      | Сидоров |
| B      | Петров  |

| Фамилия | Роль        |
| ------- | ----------- |
| Иванов  | Разработчик |
| Иванов  | Аналитик    |
| Сидоров | Аналитик    |
| Петров  | Разработчик |
| Сидоров | Разработчик |

| Проект | Роль        |
| ------ | ----------- |
| А      | Разработчик |
| А      | Аналитик    |
| B      | Аналитик    |
| B      | Разработчик |

При Join'e получаем полную ерунду!

**Шестая нормальная форма** - отношение в пятой нормальной форме и каждое непустой отношение не разложимо по соединению

Ситуация: некоторая таблица хранит временные ряды
Пример: какой сотрудник, какую должность и какую зарплату получал
В этом случае получаем зависимость зарплаты и должности относительно периода, когда он работал

База временных рядов - представляет набор таблиц, где есть:
- ключ
- начало временного ряда
- конец временного ряда
- значение

Есть общие правила:
Нужно определить, какие операции с БД будем выполнять чаще всего
Если чаще всего выборка данных (анализ данных), то тогда не имеет смысла делать нормализацию выше второй формы 

Если в БД часто предполагается изменение данных (билинговые системы, количество поездок на карточке "проездной"), то лучше все четвёртая нормальная форма

Визуально: куча мелких таблиц - продуктивная БД (ориентированная на транзакции(под транзакциями имеется ввиду обновление))
Если всего несколько больших - долгоиграющая информация с целью аналитики



### Увеличение производительности
Для того, чтобы увеличить производительность - вводится понятие `индексы`
**Индексы** - механизм, который обеспечивает высокую производительность за счёт применения дополнительных структур хранения информации

**Индексы** - это некий дополнительный файл или файлы, где данные тем или иным образом заранее структурированы и упорядочены

В реальной жизни все БД по умолчанию индексируются по первичному ключу - это значит, что сам файл БД - структурированное хранение информации по первичному ключу, т.е. **первичные индексы**

**Вторичные индексы** - индексы, построенные на полях, отличные от того, что было построено при создании таблицы

Индексы строятся на основании деревьев

Индексы могут строиться по одному атрибуту или нескольким

Очень часто индексы строятся не на всех строках, а только на тех, которые удовлетворяют условию - это называется **разряженный индекс**

*Пример*: Бухгалтер обращается к данным только 24 года, потому что ему редко нужны данные 23,22 и тд
Поэтому индексы можно построить только на данных 24 года
Запрос будет идти только к индексам

Глубина индексов тоже определяет скорость работы, дерево хочется сделать с наименьшим количеством разветвлений

Индексы крайне затрудняют работу связанную с добавлением, удалением данных
Нужно будет перестраивать дерево - это дорогое удовольствие

Если мы работаем со строковыми данными, то индексы строятся слева направо, т.е. по правилам чтения слов 

**Кластерный индекс** - таблица, ситуация, когда на нижних частях индекса хранятся фактически строки
**Некластерные индексы** - на нижних частях индекса хранятся ссылки на область дисковой памяти, где будут находиться наши данные

Кроме индексов, основанных на деревьях, бывают **хеш индексы** (Oracle используют)
Данные хранятся в виде ключ-значение, где ключ - данные, которые мы индексируем, значение - адрес на диске, где находится данная строчка

**Битовые маски** - ситуация, когда например столбец содержит три значения:
мужской пол, женский, не определено 

Посчитать всех мужчин - долгая, нудная работа
Поэтому можно сделать 3 битовых массива, где каждый бит - одна строка
Первый битовый массив - Male (там, где в строке будет мужчина, будет единичка)
Второй битовый массив - Female (там где женщина - будет единичка)
Третий - там где Null, будет стоять единичка

**Пример работы**:

| UserID | Gender  |
|--------|---------|
| 1      | Male    |
| 2      | Female  |
| 3      | Male    |
| 4      | Unknown |

Битовые маски будут выглядеть так:

- **Male**: 1 0 1 0
- **Female**: 0 1 0 0
- **Unknown**: 0 0 0 1

Получаем битовые маски, которые позволяют быстро выяснить, какие значения в какой строке находятся 
Применяет в Oracle
Длинна массива = кол-во кортежей


## Представления
**Представления** - механизм, который позволяет нам именовать результат выполнения запроса. (Это не ОТВ)

Берём запрос и говорим, что этот запрос теперь называется "так", и пользователь теперь может обратиться к результату выполнения этого запроса по имени запроса

Пример: Представление - сотрудники с данными о проживании

#### Преимущества: 
1. Улучшение визуализации
Представления нужны для лучшей визуализации данных, чтобы пользователю было удобнее смотреть на название товара и на название категории, к которой он относится
2. Безопасность
Можем создать представление, которое будет хранить только данные какого-то отдела и пользователю давать только данные его отдела
3. Эмуляция архитектуры (обратная совместимость)
Есть приложение, которое написано не мной, а каким-то контр-агентом. Он работает с БД, БД у меня меняется с течением времени, но изменить приложение я не могу, нет исходника кода. Я могу взять в виде представления эмуляцию БД, которая была раньше, он будет её воспринимать, как старую БД, на самом деле будет работать с новой.

Представления бывают **двух видов:**
1. Классическое представление - как имя запроса, к которому можем обратиться
2. Материализованное представление - моментальный снимок данных, на момент создания представления
	Пример: Хочу создать представления 4 потока, на момент 14 числа он будет состоять из каких-то единиц, но к концу семестра их может стать меньше, но у нас будет представление, на момент создания
Существуют в Postgres, Oracle
В Microsoft существуют как представление и на него индекс 

Плюсы материлизованного представления:
1. В ряде случаев облегчает производительность, но это всего лишь видимость, потому что работая с материлизованными представлениями, мы работаем со старыми данными

Существует такая штука - **обновляемость**
Если представление создано на базе одной таблицы и нет агрегирующих функций, то теоретически, через представления можно обновлять данные

Пример: есть таблица студентов, выбрал студентов только групп 15-19, могу обновить студенту фамилию, но поскольку с представлениями работают с несколькими таблицами, обновляемость у них отсутствует

В основном используются ради улучшения читаемости данных

Data Marts - реализуются представлениями - термин хранилищ данных(всего лишь визуализация) - используется для визуализации части данных 






