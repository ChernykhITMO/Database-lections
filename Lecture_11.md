
Временные ряды

Date - у - м - d

time - h - m - s

DateTime - 

TimeStamp - (дата время, либо время с учётом с учётом сдвига по часовым поясам)

Interval -  

Майкрософт купили библиотеки, поээтому у них нет Interval

# Форматы хранения 

String - "год-месяц-month-"

не очень удобно

Unix-stile - 1970 января - 0, дальше прибавляются секунды

минус: с точностью до секунд
нужно хранить даты до 1970

в MsSQL - DateTime

### Binary

4 байта на дату, 4 на время

### 

MonjoDb - хранит только 

Redis 


# Проблемы 
1. Разные форматы хранения времени
2. UTC - (Coordinate universal time )  - часовой сдвиг для хранения времени
3. DST - отвечает за хранение летнего времени
4. Точность данных 
5. Проблема с производительностью (поиск строки с соответствующим временем)

Варианты исправления:
Хранить как отдельные атрибуты дату, месяц, время

# Операции с датой временем
1. Получение разницы диапазона по времени
Проблема:
Может исчисляться в разных типах данных

Корея - декады

2.Преобразование в строку 

"год-месяц"
"месяц-день-год"

Строки могут быть разные 

3. Фильтрация по диапазону 
от 0 до 23:59

Извлечение частей 
Вырезать только год, только месяц и тд

Вывод: 
Лучше хранить с использованием UTC
Использовать индексации


# Базы данных временных рядов
# Time Series DB

набор данных которые упорядочены по времени
Главный признак идентификации - признак времени
Финансовые данные 
Сенсорные данные
Билинговые системы (звонки сотовых телефонов, трафики и тд)
Производительность IT систем (загрузки систем, трафик и тд)

Оперируют времеными метками Time Stamp 

Собираются раз с высокой частотой (раз в секунду, раз в минуту)


Для чего нужны:
1. Большие объемы данных
2. Поиски временных паттернов (аномалий или закономерностей)
3. Специфика запросов (всевозможные скользящие запросы)

Особенности: 
Эффективное хранение
БД предлагают сжатие данных на лету, чтобы хранить больше
И такие данные хорошо сжимаются

Такие системы хорошо хранят дельты предыдущих значений

На этапе загрузки происходит индексация 

Использование предустановленных агрегаторов, которые заранее формируют какие-то значения

пример: китайская колонка Повыша 

Горизонтальная масштабируемость - легко 

Максимальное упрощение запросов - пожертвуем нормальностью - будем хранить всё в одной табличке

Кроме реляционных моделей есть influx DB - open source разработка, имеет unflux QL - язык запросов (практически полностью повторяет SQL)
Особенность:
1. Заранее создана исключительно для хранения временных рядов
Система Grafana  - системы которая визуализирует данные на графиках 

Prometheus - собственный язык prom QL 
Мониторинг 

TimescaleDB - надстройка над postgress'ом 

Postgres и MsSQL тоже могут работать с временными рядами


Модели:
1. Data Points - хранит метрику, значения, метаданные
2. Time Serias - группа точек, которые имеют одинаковые показатели
(локальный прокси)

**Яндекс пиксель  **- 

Трафик надо резать
Для этого нужен прокси

VPN
Глубокий анализ пакетов 
Всё равно что то грузите 


## Механизм записи

Используется внешний API или REST запросы

## Механизмы чтения

SQL подобные языки

## Системы хранения

1. Хранить данные в лоб (дорого и неэффективно)
2. Блоки по времени (2022 год, месяц и тд)
3. Используется сжатие (частичная архивация данных) Down Cempling
Блоки которые не используются, выкидываются 
пример: интернет вещи, датчики, науко-исследование

# Проблемы
1. Высокий объем данных, сжатие архивация, удаление устаревших данных (Time to live)
пример: Поменяли колодки, можно слить данные о предыдущих
2. Масштабируемость 
3. Проблема доступа
Буферизация данных - kafka, rebbit
4. Ассинхронная запись - отдаём данные в надежде, что они запишутся, но н
5. Оптимизация запросов - нужно индексировать, предварительно агрегировать 
6. Проблема анализа в реальном времени 
7. Совместность с другими системами
JSON, CSV, Parcet 
8. Синхронизация по времени 
Датчик и сервер могут жить по разным временам

Network Time Protocol - синхронизация по времени


# Связь с Block Chain'ом

Линейная структура данных - никогда не добавляются Post Factum 

2. Большие объемы данных 
3. Ориентация на целостность и ориентация на исторический анализ
Основная задача - доверие к временной метки (чтобы нельзя было сделать задним числом)

4. Постоянный аудит (нужно фиксировать изменения)
Никто не даст в лоб изменять данные после того как они были записаны 

5. Токенизация и монетизация данных 
временные метки и блок чейн - про деньги
и то и другое про бизнес
6. Гарантия целостности 

# Интервальные данные 

проблема хранить интервалы (3 часа, 2 года)

Interval - не все системы поддерживают их

## Операции
Все арифметические 

## 

MySQL не поддерживает
Oracle поддерживает 

MsSQL: Assembying - возможность написать класс интервал на C условно и заассемблить внутрь MsSQL 

## Преимущества интервальных данных

Удобный механизм хранения посчитанной заранее информации

Резко увеличивает читаемость запросов 

Поддержка реализации визуальных дашбоардов

## Проблемы

Полное отсутствие стандартов, понимания 

Никакой совместимости

Никаких сложных операций

## Где используются
Системы броинрвоания
Логистика
Финансовый анализ
Производительность на отрезке 

## Как повысить эффективность 
1. Индексирование интервальных данных
специфические - R деревья - для оптимизации 












