Первые подходы к БД

## Иерархическая модель
Одна из самых первых моделей хранения данных и одна из самых простых

Имеет древовидную структуру
Отношение: Родитель -> ребёнок
Связь однозначная и всегда выполняется правило: 
- У одного родителя может быть много потомков, у одного ребёнка может быть один родитель
- Связи не пересекаются

**Сущность** - элемент, между которыми связи

В такой модели запрос выполняется в виде последовательного обхода дерева

У этой модели очень быстрый поиск единичной информации

Как только появляется поиск нескольких значений, то такой поиск начинается неудобным

**Вставка данных**
Вставка влечёт за собой перестройку дерева - это ресурсоёмкий процесс 
Вставка - перестройка всего файла 

Самый примитивный пример иерархической модели - файловая структра
Отдел -> сотрудник -> задачи

### Преимущества: 
1. Модель простая и подходит для жёстко структурированных иерархий
2. Высокая производительность на ряде запросов
Т.е. если нужно получить список всех сотрудников, то делается на раз два
Если нужно получить всех Ивановых, то такой запрос становится сложным, потому что нужно обойти всё дерево
3. Целостность
Если правильно продумаем структуру, то данные будут целостными(не будут дублироваться)

Пример: приходим в магазин, купить сверло, если покупаем два сверла ф8 одинаковых, но если у них разные производители - разные продукты

### Недостатки:
1. Нет гибкости, нет возможности создать структуру, где есть несколько родителей
-> вытекает проблема: невозможность быстро обновлять данные 
Невозможно делать сложные вопросы 

2. Ситуация, когда данные целостные, но при этом избыточные
Пример: Выпускаются футболки, отличаются только цветом, но при это состав и описание принта - идентичны. Создать в иерархической модели одно описание, которое будет присутствовать у нескольких экземпляров - невозможно, т.к. каждому экземпляру нужно своё описание, из этого вытекает избыточность.

Пример иерархических моделей данных в современном мире:
1. Прежде всего это файловые системы, кроме файловых систем, которые используются на ленточных носителях
2. XML, JSON

## Сетевая модель 
Граф, где есть отношение многим ко многим 

Record (запись) - некий логически связанный набор информации, который может содержать несколько полей
пример: ФИО, адрес доставки

Link/Set - связь м/у записями:
Один к одному
Один ко многим
Многие ко многим

Связь может быть поставлена на модели данных, как одно ребро, а на самом деле множественная
Один клиент имеет множество заказов, заказ состоит из множества продуктов

Sets - множество, есть понятие "владелец" записи и "член записи"
Например: набор сущности Клиент - заказ
Где клиент - владелец, заказ - член записи

Выборка данных осуществляется по графу, переход от одной записи к другой

### Преимущества:
1. Высокая гибкость 
2. Хорошая производительность по поиску информацию 
Хорошая производительность = предзапрос
Предзапрос - заранее оптимизированный путь по графу, где меняется только параметр

Пример: Найти Иванова или Петров по фамилии, но не найти клиента по количеству заказов.

3. Хорошая целостность данных
4. Последовательный доступ к связным данным
Т.к. осуществляется путь по графу
### Недостатки:
1. Трудно спроектировать качественную модель 
2. Обновлять данные сложно
Так же как и в иерархической модели
3. Невозможно написать поисковый запрос
Придётся обойти весь граф, чтобы найти информацию
4. Ограничение по стандартизации совместного использования
Потому что редко используется 


IDMS - Integrated Database Management System
Первая сетевая БД, которую использовали 

Knowledge Base - Базы знаний

ИИ (ChatGPT) - работает на подборе коэффициентов связи между элементами. И представляет собой огромные вектора, кучу коэффициентов. Коэффициенты весовые, они меняются, поэтому на одни и те же запросы ChatGPT может давать немного разные ответы. 

А Knowledge Base - жёсткая связанное графовое представление информации

Пытались сделать на сетевых моделях, но не очень получилось

Neo4 - самая известная сетевая модель БД, называется графовая

## Реляционная модель 
Набор двумерных связанных таблиц 

## Постреляционная модель

В реляционной модели типы данных ограниченные атомарностью, т.е. они должны хранить единицу информации, которые нельзя интерпретировать, как набор информации

В постреляционной хранятся наборы информаций
Поддерживает *коллекции*

В реляционной модели связи как таковой нет, проверяется соответствие значения в определённой строке, пересекаемой с определённым столбцом (этим управляет СУБД)

В постреляционной есть понятие *ссылки* - мы можем хранить ссылку на какую-то конкретную строку другой таблицы

Поддерживается подход операции с данными, т.е мы можем иметь ещё внутри таблицы что-то вроде формул (механизм обработки данных(но не ООП) (типа как в экселе формулы))

В реляционной модели допускается столбец, который будет формировать результат из соседних данных

В постреляционной можем брать данные ещё откуда-то

В постреляционных, обрабатывая одну строку, мы можем обрабатывать параллельно другие

Поддерживаются всевозможные форматы типа JSON и тд

### Преимущества:
1. Гибкость 
2. Возможность работать с неструктурированными данными
Можем хранить разнотипные данные (т.е. по ссылкам брать совсем другие типы) и их обрабатывать
3. Уменьшение избыточности
4. Поддержка объектных данных
5. Из-за того, что поддерживает разнотипные данные, то не нужно прыгать по таблицам. Т.е. можем в одной таблице хранить музыку, фотки и тд.

### Недостатки:
1. Сложность проектирования
Постреляционные БД это некий кастом, под какую-то определённую задачу -> нет стандартизации
3. Поддерживает SQL, но при этом это упрощённый вариант SQL
4. Высокопроизводительные системы обработки, т.к. не структурированные данные 
5. Поскольку нет стандартов, то проблемы при разработке 

Пример: Postgress хоть и традиционно относится к реляционным, но он поддерживает хитрые форматы данных, типа JSON, поэтому это постреляционная модель
Теоретические Postgress поддерживает ссылки, но не используется

### Многомерные модели 

| Модель |  Месяц  | Количество |
| :----: | :-----: | :--------: |
|  BMW   | январь  |     10     |
|  BMW   | февраль |     20     |
|  MERC  | январь  |     5      |
|  OPEL  | январь  |     3      |
|  OPEL  |  март   |     10     |

| BMW  | Январь | Февраль | Март |
| :--: | :----: | ------- | ---- |
| MERC |   10   | 20      | No   |
| OPEL |   5    | No      | No   |
| OPEL |   3    | No      | 10   |
Кажется неудобным, потому что, если появится ещё один месяц, то придётся создавать ещё один столбец

С другой стороны, если мы используем многомерный подход, мы можем эти данные представить в виде кубика - трёхмерный
Можно представить четырёхмерный 

Легко представить и пятимерный

|     Факт продажи      |
| :-------------------: |
|       Id марки        |
|       id месяца       |
|        id года        |
|      id региона       |
|    id тип клиента     |
|    id класс марки     |
| количество - значение |

|   Марка   |
| :-------: |
| Id марки  |
| id месяца |
|  id года  |
и тд

Ещё может быть *Иерархия измерений* в многомерной модели

Более детально - модель, ещё что-то, ещё что-то
Такая штука называется OLAP - Online Analitical Processing (онлайн кубы) 

Операции:
**Roll up** - свёртка (по какому-то измерению переходим к более высокому уровню)

Пример: регион -> страна

Drill down - операция, которая в теории развёртывает с иерархии высокого уровня, на более детальную 
Пример: Год -> месяц
Данные должны храниться до агрегации

Slice - срез (по году, по модели, по месяцу)

Dice - взять кусочек куба (несколько слайсов)

#### Преимущества:
1. Очень удобно получать данные, совершенно очевидные признак агрегирования 
2. Интуитивная визуализация данных
3. Эффективный анализ
При достаточно объеме детализации, можем делать хорошие аналитические запросы 

Пример: Заходим на яндекс маркет, находим нужный товар, заходим через режим инкогнито (будет существенно дешевле)

4. Поддержка аналитических запросов
Строятся так или иначе реляционных моделях

ROLAP - реляционные OLAP кубы
MOLAP - многомерные OLAP кубы, построенные на постреляционных моделях (когда в ячейке что-то хранится через запятую)
HOLAP - всевозможные гибридные версии (и через запятую, и атомарные)

#### Недостатки:
1. Очень сложно модифицировать с точки зрения структуры данных 
Если понадобится добавить ещё данные, придётся много чего перестраивать 
2. Невозможность хранить множество одновременно по одному предмету 
Нужно хранить много таблиц фактов
3. Происходит многократное дублирование данных

|  Id Года  |
| :-------: |
| Id месяца |
тут много хранится 2024 года

Используются в анализе данных

Пример справочника:
Две конкурирующие телефонные компании, телефонные справочники
Появился чел, который сказал, кто мне больше заплатит, тот повысит продажи в разы
Человек предложил сделать справочник чуть меньшего формата, а не А4 и тогда справочник закрывал справочник конкурента 

Как полностью исключить кражи обуви на фабриках?
Продавать одну часть на одной фабрике, вторую на другой

## Объектно-ориентированная модель
Смысл: хранить не данные, а объекты

Объект - экземпляр класса, который наполнен какой-то информацией

Фактически - хранятся куски памяти 

#### Преимущества:
1. Полностью исчезают проблемы несоответствия данных внутри программы и данных хранения (всё в одном объекте)
2. Не требуется поддерживать работу СУБД с моделью данных
3. Поскольку типизорованна, REFACTORING прост
- Поскольку данные и поведение (методы) находятся в одном объекте, рефакторинг (изменение кода) становится проще. Если вы хотите изменить структуру данных или логику работы с ними, вы изменяете только сам объект, и все изменения автоматически затрагивают как базу данных, так и программу.
5. Можно хранить не только данные, но и что традиционно не хранимо
Пример: интерфейсы

#### Минус:
Полная привязка к ООП

Сейчас есть уверенность, что ООП в будущем не потенциальный

## Колоночно-ориентированные модели
Храним не таблицы, а отдельные колонки

Таблица Product

| Id  | Name | Color |
| :-: | ---- | ----- |
|     |      | Null  |
|     |      | Null  |
Null всё равно занимает какое-то место на диске

Но если хранить отдельные колонки, то столбец Color просто будет меньше

Чем плотнее данные, тем быстрее осуществляется по ним поиск

Пример: 
миллиард продаж, нужно выбрать все товары, которые были с красным цветом, много из них не имели даже цвета, поэтому позволяет повысить производительность

MsSQL сервер частично поддерживает колоночно-ориентированную модель


### БД на HashTable 
Хранят 2 столбца, hash code и значение
Hash code - число, 4, 8, 32 байта
В качестве значения - всё что угодно

Т.е. можно сказать, как свалка 

JSON, XML, Parket - частные решения подходов





















