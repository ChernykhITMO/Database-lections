### Надёжность

Обеспечивается на всех этапах жизни системы, а это проектирование, реализация, эксплуатация, выход из эксплуатация

1. Т.е. надёжность должна быть на всех этапах жизни системы
2. Система может работать штатно, а может работать в аварийной ситуации
Надёжность должна быть в любых эксплуатационных ситуациях

Существует два вида надёжности сохранения данных: 
- Физическая
- Логическая

Надёжность должна быть не только на этапе хранения данных, но и на передаче, получении

Гарантированный доступ к данным - должны обеспечить с определённой скоростью

Физическую надёжность обеспечить достаточно просто:
Всевозможные рейды (рейд-массивы)
Как правило, когда покупаешь сервер - это не выгодно
Используешь на часть мощность, а платишь за всё

Когда арендуешь сервер, всё что связанно с системой данных, всё делегируется на сторону, которая этот сервер предоставила
В современном мире никто не арендует физический сервер, арендуют виртуальную машину (нарезают сколько-то ядер, нарезал сколько-то памяти, нарезал сколько-то дискового пространства)
Хранение придётся в рейд массивах(массиво-избыточные диски)

Резервирование компонентов и сетевых систем 
Мы должны иметь всегда две хорошие системы одновременно, если одна выходит, вторая резервирует
Никто не ставит сервер на железо, для того, чтобы можно было менять железо
Кроме этого, мы должны обеспечить резервное копирование данных

Резервное копирование данных
3 подхода
1. Создание полных резервных копий
Есть понедельник, вторник, воскресенье
По воскресеньям делаем полную резервную копию, скопировали всё и вся
(Никто не хранить копии на SSD дисках
Они имеют тендецию - умирать, если их не эксплуатировать)
2. По воскресеньям полную резервную копию, в понедельник делаем резервную копию за понедельник, во вторник за вторник, т.е. копии накапливаются и если где-то произошла проблема, то накатываем полную копию и остальные дни
(ПО копируют только изменяющиеся файлы, никто не копирует всё подряд)
3. Каждый день делаем резервную копию

Возникает вопрос, как хранить данные?
Сколько резервных копий (штук) надо хранить и на какую глубину?
Каждая резервная копия стоит денег - поэтому появляется определение "глубина хранения", а так же "время восстановления резервной копии"

Если делаем не часто, то время восстановления будет большим, поэтому нужно балансирование 

Когда делаем резервную копию - она под нагрузкой, поэтому делается, когда меньшая нагрузка

Резервные копии нужно хранить как можно дальше от основных данных
Приличные люди хранят данные на другом континенте 
У визы один в США, другой в Европе 

Что касается физической надёжности, всего лишь вопрос денег
Логическую надёжность в разы тяжелее

Для обеспечения логической надёжности нужна поддержка предметной области
Мы должны обеспечить согласованность данных
И говоря о надёжности, мы должны обеспечить переход из одного согласованного состояния в другое согласованное состояние 

Есть проблемы:
Значительное количество действий, которые являются логически законченныи и логическими едиными, они требуют нахождения БД в один момент в несогласованном состоянии. Если платим банковской картой, то момент, когда деньги списываются, а магазину зачисляются, это происходит последовательно, в момент когда списались, а продавцу не записались, если произойдёт бам, то деньги исчезнут.

Цифровые деньги - это факт того, что вы доверяете, что банк за вас совершит взаимодействие с поставщиком услуг, и договорится как-то с поставщиком услуг, чтобы поставщик вам отдал товар 

Нам необходимо обеспечить логический переход
Существует ситуация, когда согласованность данных нарушается в процессе выполнения каких-то действий
Существует нехорошая вещь, как принебрежение нормальными формами
	БД может быть не нормализованна и это может привести к несогласованности данных

Транзакция - набор действий, который внешним миром воспринимается, как атомарное действие. Транзакция выполняется целиком или не выполняется вообще.
Т.е. это как единое целое
Транзакция переводит БД из одного согласованного состояния в другое 
Для осуществления транзакции вводится понятие - журналирование
Журналирование - процесс, когда все наши действия, которые связаны с изменением БД, записываются в отдельный файл в виде запросов.
Т.е. INsert in to Table Value - этот инсёрт в виде текста будет записан в отдельный файл
Файл называется - журнал

Файл журнал необходим, для того, чтобы транзакции работали корректно 

Ситуация:
Есть временная шкала, есть точка согласования - ситуация, когда состояние ЖД и состояние оперативной памяти согласованно, т.е. всё что находится в оперативной памяти, было скинуто на жёсткий диск 
Есть точка сбоя:


1. Транзакция Т1 началась и закончилась до точки согласования и точки сбоя
с Т1 совершилась, ничего не делаем
2. Т2 началась до точки согласования, но была завершена после после точки согласования, потом произошёл сбой
В данном случае нужно будет откатить до точки согласования и часть транзакции будет восстановлена по журналу транзакции. 
3. Т3 началась после точки согласования и закончилась до точки сбоя
Никаких проблем не будет, эта транзакция будет запущена заново из журнала, после восстановления системы
4. Т4 - транзакция началась после согласования и не закончилась
Мы получим информацию, что не удалось завершить транзакцию, нас попросят повторить действие
5. Т5 - часть данных была согласована, часть данных была после согласования, но транзакция не закончилась - *самая неприятная ситуация*
Уже что-то записали на жд. Нужно сделать обратный откат, всё что вставили, удалить, данные взять из журнала, и заново выполнить транзакцию.

![[telegram-cloud-photo-size-2-5208722842810706042-y.jpg]]

Транзакции всегда выполняются одним из двух действий, либо операция commit - подтверждение транзакции, либо rollback - откатить транзакцию

Существуют ситуации, когда транзакция очень длинная 
Для этого её разбивают на точки сохранения (на кусочки)
Поэтому операция rollback может быть откачена не до всей транзакции, а до какой-то точки

4 свойства транзакции:
1. Атомарность. Транзакция неделима
Точки сохранения неделимы, это внутренняя делимость, для внешнего мира её нет
2. Согласованность
Транзакция всегда переводит БД из одного согласованного состояния в другое
Правила согласованности прописывает пользователь(администратор)
3. Изоляция
На сервере может быть запущено несколько транзакций одновременно, но при этом эти транзакции не видят друг друга и не видят изменений, т.е. транзакция не позволяет получилось доступ к данным, которые она в данный момент использует

В теории транзакции не должны мешать друг другу, но на практике совсем не так 
4. Долговечность 
Если транзакция совершена, то не смотря на то, что может происходить с железом, это значит, что у нас состояние БД целостное. С помощью журналов, других способов, добиваемся такой ситуации, когда нет несогласованности после того, как транзакция завершена. 

Проблемы:
Если не предпринять, то могут появиться:
1. Проблема обновлённых данных
Несколько транзакций могут последовательно обновлять данные и мы не будем знать, какие обновления были с данными произведены, т.е. проблема с потерями данными

Пример: Решили продавать крокодилов, за 10 тыс никто не покупают, за 9 тоже, психанули, выставили за 1 тыс и всё скупили
Никогда в жизни не узнаем информацию, что была стоимость 9 тыс рублей, если не предпринять какие-то действия 
Этот пример длительный

Если не предпримем особых мер, то утратим

2. Проблема грязных данных
Транзакции могут данные менять внутри себя и эти данные могут быть данными неадекватными и другая транзакция эти данные может считать

Пример: при закрытии депозита, деньги поступают на счёт долго, т.к. надо ещё пересчитать проценты и тд, т.е. данные не в корректном состоянии

3. Проблема повторного чтения
Если нужен самый дорогой продукт, то сделаем запрос, найдём его
Если кто-то изменит стоимость самого дорого продукта и мы сделаем запрос ещё раз, то уже будет другой результат

Но если нам надо выполнить транзакцию два раза, то мы повторно считая получим другие данные => проблема повторного чтения

4. Проблема фантомных чтений
Я считал из таблицы какое-то кол-во данных, получил 25 строк
В рамках этой же транзакции, делаю такой же запрос, но уже получаю 26 строчек 
Т.е. добавились кортежи

Решение всех проблем - блокировки 
Блокировки - закрыть на доступ часть данных, для других пользователей(транзакций)

Блокировки бывают двух видов:
1. Явная - запускает сам пользователь
2. Неявные - запускает сам SQL сервер

Блокировки могут распространяться либо на отдельные строки, либо целиком таблицу, либо полностью БД

Когда мы создаём таблицу, появляются ещё сервисные столбцы, в частности, есть номерки строк, адреса, которые позволяют идентифицировать строки по своим айдишникам

Блокировки бывают:
1. Монопольные - только транзакция имеет доступ к данным
2. Коллективная - одна транзакция блокирует данные на изменения, но другие транзакции могут её читать 

Регулярно происходят проблемы, когда транзакции пытаются блокировать друг друга
Т1 заблокировала А 
Т2 заблокировала Б 

После этого Т1 должна заблокировать Б 
Т2 заблокировать А

А они не могут, потому что уже заблокированы, произошла **взаимная блокировка**

Несколько подходов решения:
1. Построение плана запроса
SQl сервер пытается построить так, чтобы избежать эту ситуацию 
Это хорошо, если запросы не очень длинные
2. Блокировка по времени
Более молодая убивается и ставится в очередь на исполнение

Может быть ситуация: Молодая стала ещё более молодой, потом опять более молодой и тд
Это проблема, которая никак не решается, потому что время выполнения не очень долгое 

4 уровня изоляции транзакции:
1. Незавершённое чтение 
Ситуация, когда одна транзакция начала изменять данные, любая другая транзакция, которая тоже решила изменить данные, будет ждать окончание изменения транзакции первой
2. Завершённое чтение
Ситуация, если транзакция началась выполняться, то никакая другая транзакция не сможет считать затрагиваемые данные
3. Воспроизводимое чтение
Если транзакция начала читать данные, то никто не вправе изменять эти данные 
4. Сериализуемость 
Если транзакция работает с определённым набором данных, то никакая другая транзакция не сможет добавить данные, удовлетворяющие условиям первой транзакции
Ограничиваются внесения данных с такими же категориями, пока мы с ними работаем 

begin tran {имя транзакции} commit/roll back


### Безопасность 
В США была выпущена Оранжевая книга - определяет безопасность ИС

**Уровень D**
Отсутствие безопасности
**Уровень C**
Есть идентификация и аунтенфикация 
Идентифицируем объект, который пытается войти
Аутентификация - проверяем на какие-то действия 
При этом уровень C ведёт логи

**Уровень C1**
Дополнительно к C разделяет пользователей и данные 
Пользователь и данные не связаны между собой напрямую
Есть группы: Студент, преподаватель и тд.
Этому пользователю, который связан таким образом, можно получить данные, которые связаны таким образом 

**Уровень C2**
Дополнительно к C1
Каждый пользователь отличается друг от друга: Повышев, Иванов и тд
Гранулированность с точностью до пользователя

**Уровень B**
Мандатный доступ - проблема уровня С заключается, что пользователь может разгласить данные, к которым он получил доступ, в системах B делаются пометки, что можно распространять, что нет. Право на копирование.

Если Повыш в свой рабочий ноутбук вставит флешку, то на след день ему придётся писать объяснительную
Если попытается что-то скопировать (но не сможет из-за мандатного уровня в Астра линукс, в виндовсе нет), могут уволить 

B1, B2, B3 различаются уровнем паранои 

**Модель A - проверенный дизайн**

На уровне A проверяется каждый элемент кода
На этапе проектирования закладывается проверка всех правил работы

Для БД обычно характерны **ролевые подходы**, т.е. С
 
Вводится понятие, как системный администратор 
Сис админ раздаёт роли
От него нельзя писать запросы, можно давать только роли 

Администратор бэкапов - может создавать только бэкапэ
Администратор регулирования пользователей для рядовых

Как правило, когда пользователь создаёт БД, у него роль DBO(Data Base Owner)
Самый низший уровень public - должен быть замьючен 










