## Термины реляционной модели:

Отношение - таблица

Схема отношения - заголовок таблицы, названия столбцов

Кортеж - строка

Сущность - описание свойства объекта 

Атрибут - заголовок столбца

Домен - допустимые значения столбца

Значение атрибута - значение пересечения строка столбец, значение ячейки 

Ключ - один или N атрибутов

Тип данных - тип атрибута 

Отношение - двумерная таблица, которая содержит данные, содержательная часть таблицы 

Отношение появляется всегда в результате операции сложения, умножения множеств 

Пример:
Есть множество животных = {собака, лошадь}

Множество корма = {сено, мясо}

Есть сделать перемножение множеств, то получим все сочетания
```
+---------------------------------------+
|           Собака - сено               |
+---------------------------------------+
|           Собака - мясо               |  
+---------------------------------------+ <--- это декартодовое произведение
|           Лошадь - сено               | 
+---------------------------------------+
|           Лошадь - мясо               | 
+---------------------------------------+  
```



**Отношение** - это подмножество декартового произведения множеств, образующих отношение 

Сущность - некая величина, описание о котором мы храним в отношении

Пример: таблица Студенты, сущность студент

Сущности не всегда ассоциируются с конкретным объектом предметной области 

Могут ассоциироваться со связью

Атрибут - столбец

Степень отношения - количество множеств, которые составляют отношение, по сути, количество столбцов

Кардинальное число - количество кортежей

**Правила отношений:**
1. Отношение должно иметь уникальное имя
2. Уникальность имён 
3. Каждое значение атрибута должно быть неделимым (атомарным)
Определяется не сколько правилами, сколько логикой создания БД
Если в вашем понимании значение неделимо, то оно неделимо 

Пример:
Номер серия паспорта, может быть как два разных столбца, а может быть как один атрибут 

Атомарность неочевидна.

Значения атрибута берутся из определенного домена

Домен - тип данных с дополнительными ограничениями 

пример: в именах почтах нельзя использовать _ и тд



Не каждый SELECT возвращает отношение 
пример:  SELECT Color FROM Production.Product

Нет правил порядка строчек, а так же положения атрибутов относительно друг друга

От порядка атрибутов отношение ничего не утратит

Ключ - один или несколько атрибутов
Может быть однозначным, или из нескольких атрибутов, т.е. в связке

Суперключ - некоторый набор атрибутов, который обладает свойством уникальности

пример: в сущности студент, суперключём может быть номер студента, фио. 

Суперключ избыточен - можем выкинуть какой-то из атрибутов, и при этом останется уникальным 

Суперключ - уникальный набор атрибутов 

Потенциальный ключ - набор атрибутов, который обладает и уникальности и не избыточности

Общее правило: потенциальный ключ и суперключ существуют всегда

Первичный ключ - один из потенциальных ключей, удобных нам
Выбирается для проверки на равенство, значит самое удобное - целое число, потому что всё сравнивается быстро, ничего не конвертируется 

БД всегда возвращают набор строк 

Суррогатный ключ - искуственно созданный потенциальный ключ

Артикулы у магазинов бывают для удобства буквенные для удобства человека, это пример суррогатного ключа 

Каждое отношение помимо столбцов, которые мы записываем, ещё содержит:

Глобальный идентификатор - чтобы уникально идентифицировать все кортежи

Каждое отношение должно иметь атрибут с датой создания строки

Внешний ключ - атрибут или набор атрибутов дочерней таблицы, значения которых соответствуют некоторому первичному ключу

Product и дочерний Color

|         Product          |
| :----------------------: |
| Id product (primary key) |
|           Name           |
|  Id color (foreigh key)  |

|  Color   |
| :------: |
| Id color |

## Типы связи:
### 1. Один к одному
- Этот тип связи подразумевает, что каждой записи из одной таблицы соответствует одна запись в другой таблице. Пример с сотрудником и фотографией:

**Сотрудник**

| Id сотрудника (PK) | Имя   |
| ------------------ | ----- |
| 1                  | Иван  |
| 2                  | Мария |

**Фотография**

|Id фотографии (PK, FK)|Путь к фотографии|
|---|---|
|1|/images/ivan.jpg|
|2|/images/maria.jpg|
Здесь `Id фотографии` одновременно является внешним ключом (`FK`), ссылающимся на `Id сотрудника`.
### 2. Один-к-многим
- Каждой группе соответствует множество студентов, но каждый студент принадлежит только одной группе.

**Student**

| Id студента | Фамилия | Номер группы |
| ----------- | ------- | ------------ |
| 1           | Иванов  | М3219        |
| 2           | Петров  | М3218        |

**Group**

| Номер группы | Факультет |
| ------------ | --------- |
| М3219        | ИТиП      |
| М3218        | ИТиП      |

`Номер группы` в таблице `Student` — это внешний ключ, который связывает студента с его группой.

### 3. Многие ко многим
- Для демонстрации связи "многие ко многим" создадим пример с таблицами студентов и курсов. Один студент может записаться на несколько курсов, и один курс может посещаться несколькими студентами.

**Student**

| Id студента | Фамилия |
| ----------- | ------- |
| 1           | Иванов  |
| 2           | Петров  |
**Course**

| Id курса | Название курса   |
| -------- | ---------------- |
| 100      | Математика       |
| 101      | Программирование |
**Enrollment(запись)**

| Id студента | Номер курса |
| ----------- | ----------- |
| 1           | 101         |
| 1           | 102         |
| 2           | 101         |
### 4. Сам с собой (Иерархия)

| Employee_Id | Name    | Manager_Id |
| :---------: | ------- | ---------- |
|      1      | Иванов  | NULL       |
|      2      | Петров  | 1          |
|      3      | Сидоров | 2          |
- **Иванов** (ID 1) — директор. У него нет руководителя, поэтому значение в колонке `Manager_Id` для него равно `NULL`.
- **Петров** (ID 2) — главный в отделе юристов. Его руководителем является Иванов, поэтому `Manager_Id` у Петрова равно `1`.
- **Сидоров** (ID 3) — юрист в отделе юристов. Его руководителем является Петров, поэтому `Manager_Id` у Сидорова равно `2`.
## Целостность

**Целостность** бывает двух видов
#### 1. Целостность сущностей
- Все поля, участвующие в первичном ключе, должны быть заполнены и не могут содержать `NULL`
### 2. Ссылочная целостность
Ссылочная целостность обеспечивает соответствие внешнего ключа первичному ключу в связанных таблицах. Она гарантирует, что:

- **Нельзя добавить несоответствующее значение внешнего ключа**: Внешний ключ должен ссылаться на существующую запись в таблице с первичным ключом

- **Нельзя удалить или изменить первичный ключ, на который есть ссылки**: Если на запись с первичным ключом ссылаются другие записи, её изменение или удаление недопустимо без соответствующих действий для сохранения целостности


#### Действия при нарушении ссылочной целостности
СУБД предоставляют различные механизмы для обработки нарушений ссылочной целостности:
-  **СУБД не позволит нарушить ссылочную целостность**

- **Каскадные действия (CASCADE):**
    
    - При изменении или удалении записи с первичным ключом автоматически обновляются или удаляются связанные записи с внешним ключом.
    - **Пример:** Если номер товара (первичный ключ) изменяется с 1 на 25, то все записи с внешним ключом, ссылающимся на 1, также изменятся на 25.
- **Каскадное удаление (CASCADE DELETE):**
    
    - При удалении записи с первичным ключом все связанные записи с внешним ключом также удаляются.
    - **Пример:** Если удаляется запись о цвете, то все товары, связанные с этим цветом, будут удалены.
- **Замена на значение NULL (SET NULL):**
    
    - При удалении или изменении записи с первичным ключом значение внешнего ключа в связанных записях устанавливается в `NULL`.
    - **Пример:** Если удаляется клиент, поле `Customer_Id` в таблице заказов будет установлено в `NULL`.
- **Отсутствие реакции  (САМЫЙ ПЛОХОЙ ВАРИАНТ)**



